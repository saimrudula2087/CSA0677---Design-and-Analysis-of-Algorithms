#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int sum;
    int* indices;
} HeapNode;

typedef struct {
    HeapNode* nodes;
    int size;
    int capacity;
} MinHeap;

MinHeap* createMinHeap(int capacity) {
    MinHeap* heap = (MinHeap*)malloc(sizeof(MinHeap));
    heap->nodes = (HeapNode*)malloc(capacity * sizeof(HeapNode));
    heap->size = 0;
    heap->capacity = capacity;
    return heap;
}

void swap(HeapNode* a, HeapNode* b) {
    HeapNode temp = *a;
    *a = *b;
    *b = temp;
}

void minHeapify(MinHeap* heap, int index) {
    int smallest = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;
    
    if (left < heap->size && heap->nodes[left].sum < heap->nodes[smallest].sum) {
        smallest = left;
    }
    if (right < heap->size && heap->nodes[right].sum < heap->nodes[smallest].sum) {
        smallest = right;
    }
    if (smallest != index) {
        swap(&heap->nodes[smallest], &heap->nodes[index]);
        minHeapify(heap, smallest);
    }
}

void insertMinHeap(MinHeap* heap, HeapNode node) {
    if (heap->size == heap->capacity) {
        return;
    }
    heap->size++;
    int i = heap->size - 1;
    heap->nodes[i] = node;
    
    while (i != 0 && heap->nodes[(i - 1) / 2].sum > heap->nodes[i].sum) {
        swap(&heap->nodes[(i - 1) / 2], &heap->nodes[i]);
        i = (i - 1) / 2;
    }
}
HeapNode extractMin(MinHeap* heap) {
    if (heap->size <= 0) {
        HeapNode empty = {0, NULL};
        return empty;
    }
    if (heap->size == 1) {
        heap->size--;
        return heap->nodes[0];
    }    
    HeapNode root = heap->nodes[0];
    heap->nodes[0] = heap->nodes[heap->size - 1];
    heap->size--;
    minHeapify(heap, 0);   
    return root;
}
int kthSmallest(int** mat, int matSize, int* matColSize, int k) {
    int n = matColSize[0];
    MinHeap* heap = createMinHeap(k);  
    int* initialIndices = (int*)malloc(matSize * sizeof(int));
    int initialSum = 0;
    for (int i = 0; i < matSize; i++) 
	{
        initialSum += mat[i][0];
        initialIndices[i] = 0;
    }
    HeapNode initialNode = {initialSum, initialIndices};
    insertMinHeap(heap, initialNode);  
    for (int count = 0; count < k - 1; count++) 
	{
        HeapNode minNode = extractMin(heap);
        int sum = minNode.sum;
        int* indices = minNode.indices;
        for (int i = 0; i < matSize; i++) 
		{
            if (indices[i] < n - 1) 
			{
                int* newIndices = (int*)malloc(matSize * sizeof(int));
                for (int j = 0; j < matSize; j++) 
				{
                    newIndices[j] = indices[j];
                }
                newIndices[i]++;
                int newSum = sum - mat[i][indices[i]] + mat[i][newIndices[i]];
                HeapNode newNode = {newSum, newIndices};
                insertMinHeap(heap, newNode);
            }
        }
        free(indices);
    } 
    HeapNode kthNode = extractMin(heap);
    int result = kthNode.sum;
    free(kthNode.indices);
    free(heap->nodes);
    free(heap);
    return result;
}
int main() 
{
    int mat1[2][3] = {{1, 3, 11}, {2, 4, 6}};
    int* mat1Ptrs[] = {mat1[0], mat1[1]};
    int mat1ColSize = 3;
    printf("%d\n", kthSmallest(mat1Ptrs, 2, &mat1ColSize, 5)); 
    int mat2[2][3] = {{1, 3, 11}, {2, 4, 6}};
    int* mat2Ptrs[] = {mat2[0], mat2[1]};
    printf("%d\n", kthSmallest(mat2Ptrs, 2, &mat1ColSize, 9)); 
    int mat3[3][3] = {{1, 10, 10}, {1, 4, 5}, {2, 3, 6}};
    int* mat3Ptrs[] = {mat3[0], mat3[1], mat3[2]};
    int mat3ColSize = 3;
    printf("%d\n", kthSmallest(mat3Ptrs, 3, &mat3ColSize, 7)); 
}
